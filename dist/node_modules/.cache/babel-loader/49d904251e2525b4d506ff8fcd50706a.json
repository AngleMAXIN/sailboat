{"ast":null,"code":"function ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nimport * as React from 'react';\nimport classNames from 'classnames';\nimport raf from 'raf';\nimport Filler from './Filler';\nimport { getElementScrollPercentage, getScrollPercentage, getNodeHeight, getRangeIndex, getItemAbsoluteTop, GHOST_ITEM_KEY, getItemRelativeTop, getCompareItemRelativeTop, alignScrollTop, requireVirtual } from './utils/itemUtil';\nimport { getIndexByStartLoc, findListDiffIndex } from './utils/algorithmUtil';\nvar ScrollStyle = {\n  overflowY: 'auto',\n  overflowAnchor: 'none'\n};\nvar ITEM_SCALE_RATE = 1;\n/**\n * We use class component here since typescript can not support generic in function component\n *\n * Virtual list display logic:\n * 1. scroll / initialize trigger measure\n * 2. Get location item of current `scrollTop`\n * 3. [Render] Render visible items\n * 4. Get all the visible items height\n * 5. [Render] Update top item `margin-top` to fit the position\n *\n * Algorithm:\n * We split scroll bar into equal slice. An item with whatever height occupy the same range slice.\n * When `scrollTop` change,\n * it will calculate the item percentage position and move item to the position.\n * Then calculate other item position base on the located item.\n *\n * Concept:\n *\n * # located item\n * The base position item which other items position calculate base on.\n */\n\nvar List = /*#__PURE__*/function (_React$Component) {\n  _inherits(List, _React$Component);\n\n  function List(props) {\n    var _this;\n\n    _classCallCheck(this, List);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(List).call(this, props));\n    _this.listRef = React.createRef();\n    _this.itemElements = {};\n    _this.itemElementHeights = {};\n    /**\n     * Lock scroll process with `onScroll` event.\n     * This is used for `data` length change and `scrollTop` restore\n     */\n\n    _this.lockScroll = false;\n    /**\n     * Phase 2: Trigger render since we should re-calculate current position.\n     */\n\n    _this.onScroll = function (event) {\n      var _this$props = _this.props,\n          data = _this$props.data,\n          height = _this$props.height,\n          itemHeight = _this$props.itemHeight,\n          disabled = _this$props.disabled;\n      var _this$listRef$current = _this.listRef.current,\n          originScrollTop = _this$listRef$current.scrollTop,\n          clientHeight = _this$listRef$current.clientHeight,\n          scrollHeight = _this$listRef$current.scrollHeight;\n      var scrollTop = alignScrollTop(originScrollTop, scrollHeight - clientHeight); // Skip if `scrollTop` not change to avoid shake\n\n      if (scrollTop === _this.state.scrollTop || _this.lockScroll || disabled) {\n        return;\n      }\n\n      var scrollPtg = getElementScrollPercentage(_this.listRef.current);\n      var visibleCount = Math.ceil(height / itemHeight);\n\n      var _getRangeIndex = getRangeIndex(scrollPtg, data.length, visibleCount),\n          itemIndex = _getRangeIndex.itemIndex,\n          itemOffsetPtg = _getRangeIndex.itemOffsetPtg,\n          startIndex = _getRangeIndex.startIndex,\n          endIndex = _getRangeIndex.endIndex;\n\n      _this.setState({\n        status: 'MEASURE_START',\n        scrollTop: scrollTop,\n        itemIndex: itemIndex,\n        itemOffsetPtg: itemOffsetPtg,\n        startIndex: startIndex,\n        endIndex: endIndex\n      });\n\n      _this.triggerOnScroll(event);\n    };\n\n    _this.onRawScroll = function (event) {\n      var scrollTop = _this.listRef.current.scrollTop;\n\n      _this.setState({\n        scrollTop: scrollTop\n      });\n\n      _this.triggerOnScroll(event);\n    };\n\n    _this.triggerOnScroll = function (event) {\n      var onScroll = _this.props.onScroll;\n\n      if (onScroll && event) {\n        onScroll(event);\n      }\n    };\n\n    _this.getIndexKey = function (index, props) {\n      var mergedProps = props || _this.props;\n      var _mergedProps$data = mergedProps.data,\n          data = _mergedProps$data === void 0 ? [] : _mergedProps$data; // Return ghost key as latest index item\n\n      if (index === data.length) {\n        return GHOST_ITEM_KEY;\n      }\n\n      var item = data[index];\n\n      if (!item) {\n        /* istanbul ignore next */\n        console.error('Not find index item. Please report this since it is a bug.');\n      }\n\n      return _this.getItemKey(item, mergedProps);\n    };\n\n    _this.getItemKey = function (item, props) {\n      var _ref = props || _this.props,\n          itemKey = _ref.itemKey;\n\n      return typeof itemKey === 'function' ? itemKey(item) : item[itemKey];\n    };\n    /**\n     * Collect current rendered dom element item heights\n     */\n\n\n    _this.collectItemHeights = function (range) {\n      var _ref2 = range || _this.state,\n          startIndex = _ref2.startIndex,\n          endIndex = _ref2.endIndex;\n\n      var data = _this.props.data; // Record here since measure item height will get warning in `render`\n\n      for (var index = startIndex; index <= endIndex; index += 1) {\n        var item = data[index]; // Only collect exist item height\n\n        if (item) {\n          var eleKey = _this.getItemKey(item);\n\n          _this.itemElementHeights[eleKey] = getNodeHeight(_this.itemElements[eleKey]);\n        }\n      }\n    };\n\n    _this.scrollTo = function (arg0) {\n      raf(function () {\n        // Number top\n        if (_typeof(arg0) === 'object') {\n          var isVirtual = _this.state.isVirtual;\n          var _this$props2 = _this.props,\n              height = _this$props2.height,\n              itemHeight = _this$props2.itemHeight,\n              data = _this$props2.data;\n          var _arg0$align = arg0.align,\n              align = _arg0$align === void 0 ? 'auto' : _arg0$align;\n          var index = 0;\n\n          if ('index' in arg0) {\n            index = arg0.index;\n          } else if ('key' in arg0) {\n            var key = arg0.key;\n            index = data.findIndex(function (item) {\n              return _this.getItemKey(item) === key;\n            });\n          }\n\n          var visibleCount = Math.ceil(height / itemHeight);\n          var item = data[index];\n\n          if (item) {\n            var clientHeight = _this.listRef.current.clientHeight;\n\n            if (isVirtual) {\n              // Calculate related data\n              var _this$state = _this.state,\n                  itemIndex = _this$state.itemIndex,\n                  itemOffsetPtg = _this$state.itemOffsetPtg;\n              var scrollTop = _this.listRef.current.scrollTop;\n              var scrollPtg = getElementScrollPercentage(_this.listRef.current);\n              var relativeLocatedItemTop = getItemRelativeTop({\n                itemIndex: itemIndex,\n                itemOffsetPtg: itemOffsetPtg,\n                itemElementHeights: _this.itemElementHeights,\n                scrollPtg: scrollPtg,\n                clientHeight: clientHeight,\n                getItemKey: _this.getIndexKey\n              }); // We will force render related items to collect height for re-location\n\n              _this.setState({\n                startIndex: Math.max(0, index - visibleCount),\n                endIndex: Math.min(data.length - 1, index + visibleCount)\n              }, function () {\n                _this.collectItemHeights(); // Calculate related top\n\n\n                var relativeTop;\n                var mergedAlgin = align;\n\n                if (align === 'auto') {\n                  var shouldChange = true; // Check if exist in the visible range\n\n                  if (Math.abs(itemIndex - index) < visibleCount) {\n                    var itemTop = relativeLocatedItemTop;\n\n                    if (index < itemIndex) {\n                      for (var i = index; i < itemIndex; i += 1) {\n                        var eleKey = _this.getIndexKey(i);\n\n                        itemTop -= _this.itemElementHeights[eleKey] || 0;\n                      }\n                    } else {\n                      for (var _i = itemIndex; _i <= index; _i += 1) {\n                        var _eleKey = _this.getIndexKey(_i);\n\n                        itemTop += _this.itemElementHeights[_eleKey] || 0;\n                      }\n                    }\n\n                    shouldChange = itemTop <= 0 || itemTop >= clientHeight;\n                  }\n\n                  if (shouldChange) {\n                    // Out of range will fall back to position align\n                    mergedAlgin = index < itemIndex ? 'top' : 'bottom';\n                  } else {\n                    var _getRangeIndex2 = getRangeIndex(scrollPtg, data.length, visibleCount),\n                        nextIndex = _getRangeIndex2.itemIndex,\n                        newOffsetPtg = _getRangeIndex2.itemOffsetPtg,\n                        startIndex = _getRangeIndex2.startIndex,\n                        endIndex = _getRangeIndex2.endIndex;\n\n                    _this.setState({\n                      scrollTop: scrollTop,\n                      itemIndex: nextIndex,\n                      itemOffsetPtg: newOffsetPtg,\n                      startIndex: startIndex,\n                      endIndex: endIndex\n                    });\n\n                    return;\n                  }\n                } // Align with position should make scroll happen\n\n\n                if (mergedAlgin === 'top') {\n                  relativeTop = 0;\n                } else if (mergedAlgin === 'bottom') {\n                  var _eleKey2 = _this.getItemKey(item);\n\n                  relativeTop = clientHeight - _this.itemElementHeights[_eleKey2] || 0;\n                }\n\n                _this.internalScrollTo({\n                  itemIndex: index,\n                  relativeTop: relativeTop\n                });\n              });\n            } else {\n              // Raw list without virtual scroll set position directly\n              _this.collectItemHeights({\n                startIndex: 0,\n                endIndex: data.length - 1\n              });\n\n              var mergedAlgin = align; // Collection index item position\n\n              var indexItemHeight = _this.itemElementHeights[_this.getIndexKey(index)];\n\n              var itemTop = 0;\n\n              for (var i = 0; i < index; i += 1) {\n                var eleKey = _this.getIndexKey(i);\n\n                itemTop += _this.itemElementHeights[eleKey] || 0;\n              }\n\n              var itemBottom = itemTop + indexItemHeight;\n\n              if (mergedAlgin === 'auto') {\n                if (itemTop < _this.listRef.current.scrollTop) {\n                  mergedAlgin = 'top';\n                } else if (itemBottom > _this.listRef.current.scrollTop + clientHeight) {\n                  mergedAlgin = 'bottom';\n                }\n              }\n\n              if (mergedAlgin === 'top') {\n                _this.listRef.current.scrollTop = itemTop;\n              } else if (mergedAlgin === 'bottom') {\n                _this.listRef.current.scrollTop = itemTop - (clientHeight - indexItemHeight);\n              }\n            }\n          }\n        } else {\n          _this.listRef.current.scrollTop = arg0;\n        }\n      });\n    };\n    /**\n     * Phase 4: Render item and get all the visible items height\n     */\n\n\n    _this.renderChildren = function (list, startIndex, renderFunc) {\n      var status = _this.state.status; // We should measure rendered item height\n\n      return list.map(function (item, index) {\n        var eleIndex = startIndex + index;\n        var node = renderFunc(item, eleIndex, {\n          style: status === 'MEASURE_START' ? {\n            visibility: 'hidden'\n          } : {}\n        });\n\n        var eleKey = _this.getIndexKey(eleIndex); // Pass `key` and `ref` for internal measure\n\n\n        return React.cloneElement(node, {\n          key: eleKey,\n          ref: function ref(ele) {\n            _this.itemElements[eleKey] = ele;\n          }\n        });\n      });\n    };\n\n    _this.cachedProps = props;\n    _this.state = {\n      status: 'NONE',\n      scrollTop: null,\n      itemIndex: 0,\n      itemOffsetPtg: 0,\n      startIndex: 0,\n      endIndex: 0,\n      startItemTop: 0,\n      isVirtual: requireVirtual(props.height, props.itemHeight, props.data.length, props.virtual),\n      itemCount: props.data.length\n    };\n    return _this;\n  }\n\n  _createClass(List, [{\n    key: \"componentDidMount\",\n\n    /**\n     * Phase 1: Initial should sync with default scroll top\n     */\n    value: function componentDidMount() {\n      if (this.listRef.current) {\n        this.listRef.current.scrollTop = 0;\n        this.onScroll(null);\n      }\n    }\n    /**\n     * Phase 4: Record used item height\n     * Phase 5: Trigger re-render to use correct position\n     */\n\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate() {\n      var _this2 = this;\n\n      var status = this.state.status;\n      var _this$props3 = this.props,\n          data = _this$props3.data,\n          height = _this$props3.height,\n          itemHeight = _this$props3.itemHeight,\n          disabled = _this$props3.disabled,\n          onSkipRender = _this$props3.onSkipRender,\n          virtual = _this$props3.virtual;\n      var prevData = this.cachedProps.data || [];\n      var changedItemIndex = null;\n\n      if (prevData.length !== data.length) {\n        var diff = findListDiffIndex(prevData, data, this.getItemKey);\n        changedItemIndex = diff ? diff.index : null;\n      }\n\n      if (disabled) {\n        // Should trigger `onSkipRender` to tell that diff component is not render in the list\n        if (data.length > prevData.length) {\n          var _this$state2 = this.state,\n              startIndex = _this$state2.startIndex,\n              endIndex = _this$state2.endIndex;\n\n          if (onSkipRender && (changedItemIndex === null || changedItemIndex < startIndex || endIndex < changedItemIndex)) {\n            onSkipRender();\n          }\n        }\n\n        return;\n      }\n\n      var isVirtual = requireVirtual(height, itemHeight, data.length, virtual);\n      var nextStatus = status;\n\n      if (this.state.isVirtual !== isVirtual) {\n        nextStatus = isVirtual ? 'SWITCH_TO_VIRTUAL' : 'SWITCH_TO_RAW';\n        this.setState({\n          isVirtual: isVirtual,\n          status: nextStatus\n        });\n        /**\n         * We will wait a tick to let list turn to virtual list.\n         * And then use virtual list sync logic to adjust the scroll.\n         */\n\n        if (nextStatus === 'SWITCH_TO_VIRTUAL') {\n          return;\n        }\n      }\n\n      if (status === 'MEASURE_START') {\n        var _this$state3 = this.state,\n            _startIndex = _this$state3.startIndex,\n            itemIndex = _this$state3.itemIndex,\n            itemOffsetPtg = _this$state3.itemOffsetPtg;\n        var scrollTop = this.listRef.current.scrollTop; // Record here since measure item height will get warning in `render`\n\n        this.collectItemHeights(); // Calculate top visible item top offset\n\n        var locatedItemTop = getItemAbsoluteTop({\n          itemIndex: itemIndex,\n          itemOffsetPtg: itemOffsetPtg,\n          itemElementHeights: this.itemElementHeights,\n          scrollTop: scrollTop,\n          scrollPtg: getElementScrollPercentage(this.listRef.current),\n          clientHeight: this.listRef.current.clientHeight,\n          getItemKey: this.getIndexKey\n        });\n        var startItemTop = locatedItemTop;\n\n        for (var index = itemIndex - 1; index >= _startIndex; index -= 1) {\n          startItemTop -= this.itemElementHeights[this.getIndexKey(index)] || 0;\n        }\n\n        this.setState({\n          status: 'MEASURE_DONE',\n          startItemTop: startItemTop\n        });\n      }\n\n      if (status === 'SWITCH_TO_RAW') {\n        /**\n         * After virtual list back to raw list,\n         * we update the `scrollTop` to real top instead of percentage top.\n         */\n        var _this$state$cacheScro = this.state.cacheScroll,\n            _itemIndex = _this$state$cacheScro.itemIndex,\n            relativeTop = _this$state$cacheScro.relativeTop;\n        var rawTop = relativeTop;\n\n        for (var _index = 0; _index < _itemIndex; _index += 1) {\n          rawTop -= this.itemElementHeights[this.getIndexKey(_index)] || 0;\n        }\n\n        this.lockScroll = true;\n        this.listRef.current.scrollTop = -rawTop;\n        this.setState({\n          status: 'MEASURE_DONE',\n          itemIndex: 0\n        });\n        requestAnimationFrame(function () {\n          requestAnimationFrame(function () {\n            _this2.lockScroll = false;\n          });\n        });\n      } else if (prevData.length !== data.length && changedItemIndex !== null && height) {\n        /**\n         * Re-calculate the item position since `data` length changed.\n         * [IMPORTANT] We use relative position calculate here.\n         */\n        var originItemIndex = this.state.itemIndex;\n        var _this$state4 = this.state,\n            originItemOffsetPtg = _this$state4.itemOffsetPtg,\n            originStartIndex = _this$state4.startIndex,\n            originEndIndex = _this$state4.endIndex,\n            originScrollTop = _this$state4.scrollTop; // 1. Refresh item heights\n\n        this.collectItemHeights(); // 1. Get origin located item top\n\n        var originLocatedItemRelativeTop;\n\n        if (this.state.status === 'SWITCH_TO_VIRTUAL') {\n          originItemIndex = 0;\n          originLocatedItemRelativeTop = -this.state.scrollTop;\n        } else {\n          originLocatedItemRelativeTop = getItemRelativeTop({\n            itemIndex: originItemIndex,\n            itemOffsetPtg: originItemOffsetPtg,\n            itemElementHeights: this.itemElementHeights,\n            scrollPtg: getScrollPercentage({\n              scrollTop: originScrollTop,\n              scrollHeight: prevData.length * itemHeight,\n              clientHeight: this.listRef.current.clientHeight\n            }),\n            clientHeight: this.listRef.current.clientHeight,\n            getItemKey: function getItemKey(index) {\n              return _this2.getIndexKey(index, _this2.cachedProps);\n            }\n          });\n        } // 2. Find the compare item\n\n\n        var originCompareItemIndex = changedItemIndex - 1; // Use next one since there are not more item before removed\n\n        if (originCompareItemIndex < 0) {\n          originCompareItemIndex = 0;\n        } // 3. Find the compare item top\n\n\n        var originCompareItemTop = getCompareItemRelativeTop({\n          locatedItemRelativeTop: originLocatedItemRelativeTop,\n          locatedItemIndex: originItemIndex,\n          compareItemIndex: originCompareItemIndex,\n          startIndex: originStartIndex,\n          endIndex: originEndIndex,\n          getItemKey: function getItemKey(index) {\n            return _this2.getIndexKey(index, _this2.cachedProps);\n          },\n          itemElementHeights: this.itemElementHeights\n        });\n\n        if (nextStatus === 'SWITCH_TO_RAW') {\n          /**\n           * We will record current measure relative item top and apply in raw list after list turned\n           */\n          this.setState({\n            cacheScroll: {\n              itemIndex: originCompareItemIndex,\n              relativeTop: originCompareItemTop\n            }\n          });\n        } else {\n          this.internalScrollTo({\n            itemIndex: originCompareItemIndex,\n            relativeTop: originCompareItemTop\n          });\n        }\n      } else if (nextStatus === 'SWITCH_TO_RAW') {\n        // This is only trigger when height changes that all items can show in raw\n        // Let's reset back to top\n        this.setState({\n          cacheScroll: {\n            itemIndex: 0,\n            relativeTop: 0\n          }\n        });\n      }\n\n      this.cachedProps = this.props;\n    }\n  }, {\n    key: \"internalScrollTo\",\n    value: function internalScrollTo(relativeScroll) {\n      var _this3 = this;\n\n      var compareItemIndex = relativeScroll.itemIndex,\n          compareItemRelativeTop = relativeScroll.relativeTop;\n      var originScrollTop = this.state.scrollTop;\n      var _this$props4 = this.props,\n          data = _this$props4.data,\n          itemHeight = _this$props4.itemHeight,\n          height = _this$props4.height; // 1. Find the best match compare item top\n\n      var bestSimilarity = Number.MAX_VALUE;\n      var bestScrollTop = null;\n      var bestItemIndex = null;\n      var bestItemOffsetPtg = null;\n      var bestStartIndex = null;\n      var bestEndIndex = null;\n      var missSimilarity = 0;\n      var scrollHeight = data.length * itemHeight;\n      var clientHeight = this.listRef.current.clientHeight;\n      var maxScrollTop = scrollHeight - clientHeight;\n\n      for (var i = 0; i < maxScrollTop; i += 1) {\n        var scrollTop = getIndexByStartLoc(0, maxScrollTop, originScrollTop, i);\n        var scrollPtg = getScrollPercentage({\n          scrollTop: scrollTop,\n          scrollHeight: scrollHeight,\n          clientHeight: clientHeight\n        });\n        var visibleCount = Math.ceil(height / itemHeight);\n\n        var _getRangeIndex3 = getRangeIndex(scrollPtg, data.length, visibleCount),\n            itemIndex = _getRangeIndex3.itemIndex,\n            itemOffsetPtg = _getRangeIndex3.itemOffsetPtg,\n            startIndex = _getRangeIndex3.startIndex,\n            endIndex = _getRangeIndex3.endIndex; // No need to check if compare item out of the index to save performance\n\n\n        if (startIndex <= compareItemIndex && compareItemIndex <= endIndex) {\n          // 1.1 Get measure located item relative top\n          var locatedItemRelativeTop = getItemRelativeTop({\n            itemIndex: itemIndex,\n            itemOffsetPtg: itemOffsetPtg,\n            itemElementHeights: this.itemElementHeights,\n            scrollPtg: scrollPtg,\n            clientHeight: clientHeight,\n            getItemKey: this.getIndexKey\n          });\n          var compareItemTop = getCompareItemRelativeTop({\n            locatedItemRelativeTop: locatedItemRelativeTop,\n            locatedItemIndex: itemIndex,\n            compareItemIndex: compareItemIndex,\n            startIndex: startIndex,\n            endIndex: endIndex,\n            getItemKey: this.getIndexKey,\n            itemElementHeights: this.itemElementHeights\n          }); // 1.2 Find best match compare item top\n\n          var similarity = Math.abs(compareItemTop - compareItemRelativeTop);\n\n          if (similarity < bestSimilarity) {\n            bestSimilarity = similarity;\n            bestScrollTop = scrollTop;\n            bestItemIndex = itemIndex;\n            bestItemOffsetPtg = itemOffsetPtg;\n            bestStartIndex = startIndex;\n            bestEndIndex = endIndex;\n            missSimilarity = 0;\n          } else {\n            missSimilarity += 1;\n          }\n        } // If keeping 10 times not match similarity,\n        // check more scrollTop is meaningless.\n        // Here boundary is set to 10.\n\n\n        if (missSimilarity > 10) {\n          break;\n        }\n      } // 2. Re-scroll if has best scroll match\n\n\n      if (bestScrollTop !== null) {\n        this.lockScroll = true;\n        this.listRef.current.scrollTop = bestScrollTop;\n        this.setState({\n          status: 'MEASURE_START',\n          scrollTop: bestScrollTop,\n          itemIndex: bestItemIndex,\n          itemOffsetPtg: bestItemOffsetPtg,\n          startIndex: bestStartIndex,\n          endIndex: bestEndIndex\n        });\n        requestAnimationFrame(function () {\n          requestAnimationFrame(function () {\n            _this3.lockScroll = false;\n          });\n        });\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this$state5 = this.state,\n          isVirtual = _this$state5.isVirtual,\n          itemCount = _this$state5.itemCount;\n\n      var _this$props5 = this.props,\n          prefixCls = _this$props5.prefixCls,\n          style = _this$props5.style,\n          className = _this$props5.className,\n          _this$props5$componen = _this$props5.component,\n          Component = _this$props5$componen === void 0 ? 'div' : _this$props5$componen,\n          height = _this$props5.height,\n          itemHeight = _this$props5.itemHeight,\n          _this$props5$fullHeig = _this$props5.fullHeight,\n          fullHeight = _this$props5$fullHeig === void 0 ? true : _this$props5$fullHeig,\n          data = _this$props5.data,\n          children = _this$props5.children,\n          itemKey = _this$props5.itemKey,\n          onSkipRender = _this$props5.onSkipRender,\n          disabled = _this$props5.disabled,\n          virtual = _this$props5.virtual,\n          restProps = _objectWithoutProperties(_this$props5, [\"prefixCls\", \"style\", \"className\", \"component\", \"height\", \"itemHeight\", \"fullHeight\", \"data\", \"children\", \"itemKey\", \"onSkipRender\", \"disabled\", \"virtual\"]);\n\n      var mergedClassName = classNames(prefixCls, className); // Render pure list if not set height or height is enough for all items\n\n      if (!isVirtual) {\n        /**\n         * Virtual list switch is works on component updated.\n         * We should double check here if need cut the content.\n         */\n        var shouldVirtual = requireVirtual(height, itemHeight, data.length, virtual);\n        return React.createElement(Component, Object.assign({\n          style: height ? _objectSpread({}, style, _defineProperty({}, fullHeight ? 'height' : 'maxHeight', height), ScrollStyle) : style,\n          className: mergedClassName\n        }, restProps, {\n          onScroll: this.onRawScroll,\n          ref: this.listRef\n        }), React.createElement(Filler, {\n          prefixCls: prefixCls,\n          height: height\n        }, this.renderChildren(shouldVirtual ? data.slice(0, Math.ceil(height / itemHeight)) : data, 0, children)));\n      } // Use virtual list\n\n\n      var mergedStyle = _objectSpread({}, style, {\n        height: height\n      }, ScrollStyle);\n\n      var _this$state6 = this.state,\n          status = _this$state6.status,\n          startIndex = _this$state6.startIndex,\n          endIndex = _this$state6.endIndex,\n          startItemTop = _this$state6.startItemTop;\n      var contentHeight = itemCount * itemHeight * ITEM_SCALE_RATE;\n      return React.createElement(Component, Object.assign({\n        style: mergedStyle,\n        className: mergedClassName\n      }, restProps, {\n        onScroll: this.onScroll,\n        ref: this.listRef\n      }), React.createElement(Filler, {\n        prefixCls: prefixCls,\n        height: contentHeight,\n        offset: status === 'MEASURE_DONE' ? startItemTop : 0\n      }, this.renderChildren(data.slice(startIndex, endIndex + 1), startIndex, children)));\n    }\n  }], [{\n    key: \"getDerivedStateFromProps\",\n    value: function getDerivedStateFromProps(nextProps) {\n      if (!nextProps.disabled) {\n        return {\n          itemCount: nextProps.data.length\n        };\n      }\n\n      return null;\n    }\n  }]);\n\n  return List;\n}(React.Component);\n\nList.defaultProps = {\n  itemHeight: 15,\n  data: []\n};\nexport default List;","map":{"version":3,"sources":["/home/maxin/self/sailboat/dist/node_modules/rc-virtual-list/es/List.js"],"names":["ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","_defineProperty","getOwnPropertyDescriptors","defineProperties","defineProperty","obj","value","configurable","writable","_objectWithoutProperties","excluded","_objectWithoutPropertiesLoose","sourceSymbolKeys","indexOf","prototype","propertyIsEnumerable","call","sourceKeys","_typeof","Symbol","iterator","constructor","_classCallCheck","instance","Constructor","TypeError","_defineProperties","props","descriptor","_createClass","protoProps","staticProps","_possibleConstructorReturn","self","_assertThisInitialized","ReferenceError","_getPrototypeOf","o","setPrototypeOf","getPrototypeOf","__proto__","_inherits","subClass","superClass","create","_setPrototypeOf","p","React","classNames","raf","Filler","getElementScrollPercentage","getScrollPercentage","getNodeHeight","getRangeIndex","getItemAbsoluteTop","GHOST_ITEM_KEY","getItemRelativeTop","getCompareItemRelativeTop","alignScrollTop","requireVirtual","getIndexByStartLoc","findListDiffIndex","ScrollStyle","overflowY","overflowAnchor","ITEM_SCALE_RATE","List","_React$Component","_this","listRef","createRef","itemElements","itemElementHeights","lockScroll","onScroll","event","_this$props","data","height","itemHeight","disabled","_this$listRef$current","current","originScrollTop","scrollTop","clientHeight","scrollHeight","state","scrollPtg","visibleCount","Math","ceil","_getRangeIndex","itemIndex","itemOffsetPtg","startIndex","endIndex","setState","status","triggerOnScroll","onRawScroll","getIndexKey","index","mergedProps","_mergedProps$data","item","console","error","getItemKey","_ref","itemKey","collectItemHeights","range","_ref2","eleKey","scrollTo","arg0","isVirtual","_this$props2","_arg0$align","align","findIndex","_this$state","relativeLocatedItemTop","max","min","relativeTop","mergedAlgin","shouldChange","abs","itemTop","_i","_eleKey","_getRangeIndex2","nextIndex","newOffsetPtg","_eleKey2","internalScrollTo","indexItemHeight","itemBottom","renderChildren","list","renderFunc","map","eleIndex","node","style","visibility","cloneElement","ref","ele","cachedProps","startItemTop","virtual","itemCount","componentDidMount","componentDidUpdate","_this2","_this$props3","onSkipRender","prevData","changedItemIndex","diff","_this$state2","nextStatus","_this$state3","_startIndex","locatedItemTop","_this$state$cacheScro","cacheScroll","_itemIndex","rawTop","_index","requestAnimationFrame","originItemIndex","_this$state4","originItemOffsetPtg","originStartIndex","originEndIndex","originLocatedItemRelativeTop","originCompareItemIndex","originCompareItemTop","locatedItemRelativeTop","locatedItemIndex","compareItemIndex","relativeScroll","_this3","compareItemRelativeTop","_this$props4","bestSimilarity","Number","MAX_VALUE","bestScrollTop","bestItemIndex","bestItemOffsetPtg","bestStartIndex","bestEndIndex","missSimilarity","maxScrollTop","_getRangeIndex3","compareItemTop","similarity","render","_this$state5","_this$props5","prefixCls","className","_this$props5$componen","component","Component","_this$props5$fullHeig","fullHeight","children","restProps","mergedClassName","shouldVirtual","createElement","assign","slice","mergedStyle","_this$state6","contentHeight","offset","getDerivedStateFromProps","nextProps","defaultProps"],"mappings":"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","sourcesContent":["function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nimport * as React from 'react';\nimport classNames from 'classnames';\nimport raf from 'raf';\nimport Filler from './Filler';\nimport { getElementScrollPercentage, getScrollPercentage, getNodeHeight, getRangeIndex, getItemAbsoluteTop, GHOST_ITEM_KEY, getItemRelativeTop, getCompareItemRelativeTop, alignScrollTop, requireVirtual } from './utils/itemUtil';\nimport { getIndexByStartLoc, findListDiffIndex } from './utils/algorithmUtil';\nvar ScrollStyle = {\n  overflowY: 'auto',\n  overflowAnchor: 'none'\n};\nvar ITEM_SCALE_RATE = 1;\n/**\n * We use class component here since typescript can not support generic in function component\n *\n * Virtual list display logic:\n * 1. scroll / initialize trigger measure\n * 2. Get location item of current `scrollTop`\n * 3. [Render] Render visible items\n * 4. Get all the visible items height\n * 5. [Render] Update top item `margin-top` to fit the position\n *\n * Algorithm:\n * We split scroll bar into equal slice. An item with whatever height occupy the same range slice.\n * When `scrollTop` change,\n * it will calculate the item percentage position and move item to the position.\n * Then calculate other item position base on the located item.\n *\n * Concept:\n *\n * # located item\n * The base position item which other items position calculate base on.\n */\n\nvar List = /*#__PURE__*/function (_React$Component) {\n  _inherits(List, _React$Component);\n\n  function List(props) {\n    var _this;\n\n    _classCallCheck(this, List);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(List).call(this, props));\n    _this.listRef = React.createRef();\n    _this.itemElements = {};\n    _this.itemElementHeights = {};\n    /**\n     * Lock scroll process with `onScroll` event.\n     * This is used for `data` length change and `scrollTop` restore\n     */\n\n    _this.lockScroll = false;\n    /**\n     * Phase 2: Trigger render since we should re-calculate current position.\n     */\n\n    _this.onScroll = function (event) {\n      var _this$props = _this.props,\n          data = _this$props.data,\n          height = _this$props.height,\n          itemHeight = _this$props.itemHeight,\n          disabled = _this$props.disabled;\n      var _this$listRef$current = _this.listRef.current,\n          originScrollTop = _this$listRef$current.scrollTop,\n          clientHeight = _this$listRef$current.clientHeight,\n          scrollHeight = _this$listRef$current.scrollHeight;\n      var scrollTop = alignScrollTop(originScrollTop, scrollHeight - clientHeight); // Skip if `scrollTop` not change to avoid shake\n\n      if (scrollTop === _this.state.scrollTop || _this.lockScroll || disabled) {\n        return;\n      }\n\n      var scrollPtg = getElementScrollPercentage(_this.listRef.current);\n      var visibleCount = Math.ceil(height / itemHeight);\n\n      var _getRangeIndex = getRangeIndex(scrollPtg, data.length, visibleCount),\n          itemIndex = _getRangeIndex.itemIndex,\n          itemOffsetPtg = _getRangeIndex.itemOffsetPtg,\n          startIndex = _getRangeIndex.startIndex,\n          endIndex = _getRangeIndex.endIndex;\n\n      _this.setState({\n        status: 'MEASURE_START',\n        scrollTop: scrollTop,\n        itemIndex: itemIndex,\n        itemOffsetPtg: itemOffsetPtg,\n        startIndex: startIndex,\n        endIndex: endIndex\n      });\n\n      _this.triggerOnScroll(event);\n    };\n\n    _this.onRawScroll = function (event) {\n      var scrollTop = _this.listRef.current.scrollTop;\n\n      _this.setState({\n        scrollTop: scrollTop\n      });\n\n      _this.triggerOnScroll(event);\n    };\n\n    _this.triggerOnScroll = function (event) {\n      var onScroll = _this.props.onScroll;\n\n      if (onScroll && event) {\n        onScroll(event);\n      }\n    };\n\n    _this.getIndexKey = function (index, props) {\n      var mergedProps = props || _this.props;\n      var _mergedProps$data = mergedProps.data,\n          data = _mergedProps$data === void 0 ? [] : _mergedProps$data; // Return ghost key as latest index item\n\n      if (index === data.length) {\n        return GHOST_ITEM_KEY;\n      }\n\n      var item = data[index];\n\n      if (!item) {\n        /* istanbul ignore next */\n        console.error('Not find index item. Please report this since it is a bug.');\n      }\n\n      return _this.getItemKey(item, mergedProps);\n    };\n\n    _this.getItemKey = function (item, props) {\n      var _ref = props || _this.props,\n          itemKey = _ref.itemKey;\n\n      return typeof itemKey === 'function' ? itemKey(item) : item[itemKey];\n    };\n    /**\n     * Collect current rendered dom element item heights\n     */\n\n\n    _this.collectItemHeights = function (range) {\n      var _ref2 = range || _this.state,\n          startIndex = _ref2.startIndex,\n          endIndex = _ref2.endIndex;\n\n      var data = _this.props.data; // Record here since measure item height will get warning in `render`\n\n      for (var index = startIndex; index <= endIndex; index += 1) {\n        var item = data[index]; // Only collect exist item height\n\n        if (item) {\n          var eleKey = _this.getItemKey(item);\n\n          _this.itemElementHeights[eleKey] = getNodeHeight(_this.itemElements[eleKey]);\n        }\n      }\n    };\n\n    _this.scrollTo = function (arg0) {\n      raf(function () {\n        // Number top\n        if (_typeof(arg0) === 'object') {\n          var isVirtual = _this.state.isVirtual;\n          var _this$props2 = _this.props,\n              height = _this$props2.height,\n              itemHeight = _this$props2.itemHeight,\n              data = _this$props2.data;\n          var _arg0$align = arg0.align,\n              align = _arg0$align === void 0 ? 'auto' : _arg0$align;\n          var index = 0;\n\n          if ('index' in arg0) {\n            index = arg0.index;\n          } else if ('key' in arg0) {\n            var key = arg0.key;\n            index = data.findIndex(function (item) {\n              return _this.getItemKey(item) === key;\n            });\n          }\n\n          var visibleCount = Math.ceil(height / itemHeight);\n          var item = data[index];\n\n          if (item) {\n            var clientHeight = _this.listRef.current.clientHeight;\n\n            if (isVirtual) {\n              // Calculate related data\n              var _this$state = _this.state,\n                  itemIndex = _this$state.itemIndex,\n                  itemOffsetPtg = _this$state.itemOffsetPtg;\n              var scrollTop = _this.listRef.current.scrollTop;\n              var scrollPtg = getElementScrollPercentage(_this.listRef.current);\n              var relativeLocatedItemTop = getItemRelativeTop({\n                itemIndex: itemIndex,\n                itemOffsetPtg: itemOffsetPtg,\n                itemElementHeights: _this.itemElementHeights,\n                scrollPtg: scrollPtg,\n                clientHeight: clientHeight,\n                getItemKey: _this.getIndexKey\n              }); // We will force render related items to collect height for re-location\n\n              _this.setState({\n                startIndex: Math.max(0, index - visibleCount),\n                endIndex: Math.min(data.length - 1, index + visibleCount)\n              }, function () {\n                _this.collectItemHeights(); // Calculate related top\n\n\n                var relativeTop;\n                var mergedAlgin = align;\n\n                if (align === 'auto') {\n                  var shouldChange = true; // Check if exist in the visible range\n\n                  if (Math.abs(itemIndex - index) < visibleCount) {\n                    var itemTop = relativeLocatedItemTop;\n\n                    if (index < itemIndex) {\n                      for (var i = index; i < itemIndex; i += 1) {\n                        var eleKey = _this.getIndexKey(i);\n\n                        itemTop -= _this.itemElementHeights[eleKey] || 0;\n                      }\n                    } else {\n                      for (var _i = itemIndex; _i <= index; _i += 1) {\n                        var _eleKey = _this.getIndexKey(_i);\n\n                        itemTop += _this.itemElementHeights[_eleKey] || 0;\n                      }\n                    }\n\n                    shouldChange = itemTop <= 0 || itemTop >= clientHeight;\n                  }\n\n                  if (shouldChange) {\n                    // Out of range will fall back to position align\n                    mergedAlgin = index < itemIndex ? 'top' : 'bottom';\n                  } else {\n                    var _getRangeIndex2 = getRangeIndex(scrollPtg, data.length, visibleCount),\n                        nextIndex = _getRangeIndex2.itemIndex,\n                        newOffsetPtg = _getRangeIndex2.itemOffsetPtg,\n                        startIndex = _getRangeIndex2.startIndex,\n                        endIndex = _getRangeIndex2.endIndex;\n\n                    _this.setState({\n                      scrollTop: scrollTop,\n                      itemIndex: nextIndex,\n                      itemOffsetPtg: newOffsetPtg,\n                      startIndex: startIndex,\n                      endIndex: endIndex\n                    });\n\n                    return;\n                  }\n                } // Align with position should make scroll happen\n\n\n                if (mergedAlgin === 'top') {\n                  relativeTop = 0;\n                } else if (mergedAlgin === 'bottom') {\n                  var _eleKey2 = _this.getItemKey(item);\n\n                  relativeTop = clientHeight - _this.itemElementHeights[_eleKey2] || 0;\n                }\n\n                _this.internalScrollTo({\n                  itemIndex: index,\n                  relativeTop: relativeTop\n                });\n              });\n            } else {\n              // Raw list without virtual scroll set position directly\n              _this.collectItemHeights({\n                startIndex: 0,\n                endIndex: data.length - 1\n              });\n\n              var mergedAlgin = align; // Collection index item position\n\n              var indexItemHeight = _this.itemElementHeights[_this.getIndexKey(index)];\n\n              var itemTop = 0;\n\n              for (var i = 0; i < index; i += 1) {\n                var eleKey = _this.getIndexKey(i);\n\n                itemTop += _this.itemElementHeights[eleKey] || 0;\n              }\n\n              var itemBottom = itemTop + indexItemHeight;\n\n              if (mergedAlgin === 'auto') {\n                if (itemTop < _this.listRef.current.scrollTop) {\n                  mergedAlgin = 'top';\n                } else if (itemBottom > _this.listRef.current.scrollTop + clientHeight) {\n                  mergedAlgin = 'bottom';\n                }\n              }\n\n              if (mergedAlgin === 'top') {\n                _this.listRef.current.scrollTop = itemTop;\n              } else if (mergedAlgin === 'bottom') {\n                _this.listRef.current.scrollTop = itemTop - (clientHeight - indexItemHeight);\n              }\n            }\n          }\n        } else {\n          _this.listRef.current.scrollTop = arg0;\n        }\n      });\n    };\n    /**\n     * Phase 4: Render item and get all the visible items height\n     */\n\n\n    _this.renderChildren = function (list, startIndex, renderFunc) {\n      var status = _this.state.status; // We should measure rendered item height\n\n      return list.map(function (item, index) {\n        var eleIndex = startIndex + index;\n        var node = renderFunc(item, eleIndex, {\n          style: status === 'MEASURE_START' ? {\n            visibility: 'hidden'\n          } : {}\n        });\n\n        var eleKey = _this.getIndexKey(eleIndex); // Pass `key` and `ref` for internal measure\n\n\n        return React.cloneElement(node, {\n          key: eleKey,\n          ref: function ref(ele) {\n            _this.itemElements[eleKey] = ele;\n          }\n        });\n      });\n    };\n\n    _this.cachedProps = props;\n    _this.state = {\n      status: 'NONE',\n      scrollTop: null,\n      itemIndex: 0,\n      itemOffsetPtg: 0,\n      startIndex: 0,\n      endIndex: 0,\n      startItemTop: 0,\n      isVirtual: requireVirtual(props.height, props.itemHeight, props.data.length, props.virtual),\n      itemCount: props.data.length\n    };\n    return _this;\n  }\n\n  _createClass(List, [{\n    key: \"componentDidMount\",\n\n    /**\n     * Phase 1: Initial should sync with default scroll top\n     */\n    value: function componentDidMount() {\n      if (this.listRef.current) {\n        this.listRef.current.scrollTop = 0;\n        this.onScroll(null);\n      }\n    }\n    /**\n     * Phase 4: Record used item height\n     * Phase 5: Trigger re-render to use correct position\n     */\n\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate() {\n      var _this2 = this;\n\n      var status = this.state.status;\n      var _this$props3 = this.props,\n          data = _this$props3.data,\n          height = _this$props3.height,\n          itemHeight = _this$props3.itemHeight,\n          disabled = _this$props3.disabled,\n          onSkipRender = _this$props3.onSkipRender,\n          virtual = _this$props3.virtual;\n      var prevData = this.cachedProps.data || [];\n      var changedItemIndex = null;\n\n      if (prevData.length !== data.length) {\n        var diff = findListDiffIndex(prevData, data, this.getItemKey);\n        changedItemIndex = diff ? diff.index : null;\n      }\n\n      if (disabled) {\n        // Should trigger `onSkipRender` to tell that diff component is not render in the list\n        if (data.length > prevData.length) {\n          var _this$state2 = this.state,\n              startIndex = _this$state2.startIndex,\n              endIndex = _this$state2.endIndex;\n\n          if (onSkipRender && (changedItemIndex === null || changedItemIndex < startIndex || endIndex < changedItemIndex)) {\n            onSkipRender();\n          }\n        }\n\n        return;\n      }\n\n      var isVirtual = requireVirtual(height, itemHeight, data.length, virtual);\n      var nextStatus = status;\n\n      if (this.state.isVirtual !== isVirtual) {\n        nextStatus = isVirtual ? 'SWITCH_TO_VIRTUAL' : 'SWITCH_TO_RAW';\n        this.setState({\n          isVirtual: isVirtual,\n          status: nextStatus\n        });\n        /**\n         * We will wait a tick to let list turn to virtual list.\n         * And then use virtual list sync logic to adjust the scroll.\n         */\n\n        if (nextStatus === 'SWITCH_TO_VIRTUAL') {\n          return;\n        }\n      }\n\n      if (status === 'MEASURE_START') {\n        var _this$state3 = this.state,\n            _startIndex = _this$state3.startIndex,\n            itemIndex = _this$state3.itemIndex,\n            itemOffsetPtg = _this$state3.itemOffsetPtg;\n        var scrollTop = this.listRef.current.scrollTop; // Record here since measure item height will get warning in `render`\n\n        this.collectItemHeights(); // Calculate top visible item top offset\n\n        var locatedItemTop = getItemAbsoluteTop({\n          itemIndex: itemIndex,\n          itemOffsetPtg: itemOffsetPtg,\n          itemElementHeights: this.itemElementHeights,\n          scrollTop: scrollTop,\n          scrollPtg: getElementScrollPercentage(this.listRef.current),\n          clientHeight: this.listRef.current.clientHeight,\n          getItemKey: this.getIndexKey\n        });\n        var startItemTop = locatedItemTop;\n\n        for (var index = itemIndex - 1; index >= _startIndex; index -= 1) {\n          startItemTop -= this.itemElementHeights[this.getIndexKey(index)] || 0;\n        }\n\n        this.setState({\n          status: 'MEASURE_DONE',\n          startItemTop: startItemTop\n        });\n      }\n\n      if (status === 'SWITCH_TO_RAW') {\n        /**\n         * After virtual list back to raw list,\n         * we update the `scrollTop` to real top instead of percentage top.\n         */\n        var _this$state$cacheScro = this.state.cacheScroll,\n            _itemIndex = _this$state$cacheScro.itemIndex,\n            relativeTop = _this$state$cacheScro.relativeTop;\n        var rawTop = relativeTop;\n\n        for (var _index = 0; _index < _itemIndex; _index += 1) {\n          rawTop -= this.itemElementHeights[this.getIndexKey(_index)] || 0;\n        }\n\n        this.lockScroll = true;\n        this.listRef.current.scrollTop = -rawTop;\n        this.setState({\n          status: 'MEASURE_DONE',\n          itemIndex: 0\n        });\n        requestAnimationFrame(function () {\n          requestAnimationFrame(function () {\n            _this2.lockScroll = false;\n          });\n        });\n      } else if (prevData.length !== data.length && changedItemIndex !== null && height) {\n        /**\n         * Re-calculate the item position since `data` length changed.\n         * [IMPORTANT] We use relative position calculate here.\n         */\n        var originItemIndex = this.state.itemIndex;\n        var _this$state4 = this.state,\n            originItemOffsetPtg = _this$state4.itemOffsetPtg,\n            originStartIndex = _this$state4.startIndex,\n            originEndIndex = _this$state4.endIndex,\n            originScrollTop = _this$state4.scrollTop; // 1. Refresh item heights\n\n        this.collectItemHeights(); // 1. Get origin located item top\n\n        var originLocatedItemRelativeTop;\n\n        if (this.state.status === 'SWITCH_TO_VIRTUAL') {\n          originItemIndex = 0;\n          originLocatedItemRelativeTop = -this.state.scrollTop;\n        } else {\n          originLocatedItemRelativeTop = getItemRelativeTop({\n            itemIndex: originItemIndex,\n            itemOffsetPtg: originItemOffsetPtg,\n            itemElementHeights: this.itemElementHeights,\n            scrollPtg: getScrollPercentage({\n              scrollTop: originScrollTop,\n              scrollHeight: prevData.length * itemHeight,\n              clientHeight: this.listRef.current.clientHeight\n            }),\n            clientHeight: this.listRef.current.clientHeight,\n            getItemKey: function getItemKey(index) {\n              return _this2.getIndexKey(index, _this2.cachedProps);\n            }\n          });\n        } // 2. Find the compare item\n\n\n        var originCompareItemIndex = changedItemIndex - 1; // Use next one since there are not more item before removed\n\n        if (originCompareItemIndex < 0) {\n          originCompareItemIndex = 0;\n        } // 3. Find the compare item top\n\n\n        var originCompareItemTop = getCompareItemRelativeTop({\n          locatedItemRelativeTop: originLocatedItemRelativeTop,\n          locatedItemIndex: originItemIndex,\n          compareItemIndex: originCompareItemIndex,\n          startIndex: originStartIndex,\n          endIndex: originEndIndex,\n          getItemKey: function getItemKey(index) {\n            return _this2.getIndexKey(index, _this2.cachedProps);\n          },\n          itemElementHeights: this.itemElementHeights\n        });\n\n        if (nextStatus === 'SWITCH_TO_RAW') {\n          /**\n           * We will record current measure relative item top and apply in raw list after list turned\n           */\n          this.setState({\n            cacheScroll: {\n              itemIndex: originCompareItemIndex,\n              relativeTop: originCompareItemTop\n            }\n          });\n        } else {\n          this.internalScrollTo({\n            itemIndex: originCompareItemIndex,\n            relativeTop: originCompareItemTop\n          });\n        }\n      } else if (nextStatus === 'SWITCH_TO_RAW') {\n        // This is only trigger when height changes that all items can show in raw\n        // Let's reset back to top\n        this.setState({\n          cacheScroll: {\n            itemIndex: 0,\n            relativeTop: 0\n          }\n        });\n      }\n\n      this.cachedProps = this.props;\n    }\n  }, {\n    key: \"internalScrollTo\",\n    value: function internalScrollTo(relativeScroll) {\n      var _this3 = this;\n\n      var compareItemIndex = relativeScroll.itemIndex,\n          compareItemRelativeTop = relativeScroll.relativeTop;\n      var originScrollTop = this.state.scrollTop;\n      var _this$props4 = this.props,\n          data = _this$props4.data,\n          itemHeight = _this$props4.itemHeight,\n          height = _this$props4.height; // 1. Find the best match compare item top\n\n      var bestSimilarity = Number.MAX_VALUE;\n      var bestScrollTop = null;\n      var bestItemIndex = null;\n      var bestItemOffsetPtg = null;\n      var bestStartIndex = null;\n      var bestEndIndex = null;\n      var missSimilarity = 0;\n      var scrollHeight = data.length * itemHeight;\n      var clientHeight = this.listRef.current.clientHeight;\n      var maxScrollTop = scrollHeight - clientHeight;\n\n      for (var i = 0; i < maxScrollTop; i += 1) {\n        var scrollTop = getIndexByStartLoc(0, maxScrollTop, originScrollTop, i);\n        var scrollPtg = getScrollPercentage({\n          scrollTop: scrollTop,\n          scrollHeight: scrollHeight,\n          clientHeight: clientHeight\n        });\n        var visibleCount = Math.ceil(height / itemHeight);\n\n        var _getRangeIndex3 = getRangeIndex(scrollPtg, data.length, visibleCount),\n            itemIndex = _getRangeIndex3.itemIndex,\n            itemOffsetPtg = _getRangeIndex3.itemOffsetPtg,\n            startIndex = _getRangeIndex3.startIndex,\n            endIndex = _getRangeIndex3.endIndex; // No need to check if compare item out of the index to save performance\n\n\n        if (startIndex <= compareItemIndex && compareItemIndex <= endIndex) {\n          // 1.1 Get measure located item relative top\n          var locatedItemRelativeTop = getItemRelativeTop({\n            itemIndex: itemIndex,\n            itemOffsetPtg: itemOffsetPtg,\n            itemElementHeights: this.itemElementHeights,\n            scrollPtg: scrollPtg,\n            clientHeight: clientHeight,\n            getItemKey: this.getIndexKey\n          });\n          var compareItemTop = getCompareItemRelativeTop({\n            locatedItemRelativeTop: locatedItemRelativeTop,\n            locatedItemIndex: itemIndex,\n            compareItemIndex: compareItemIndex,\n            startIndex: startIndex,\n            endIndex: endIndex,\n            getItemKey: this.getIndexKey,\n            itemElementHeights: this.itemElementHeights\n          }); // 1.2 Find best match compare item top\n\n          var similarity = Math.abs(compareItemTop - compareItemRelativeTop);\n\n          if (similarity < bestSimilarity) {\n            bestSimilarity = similarity;\n            bestScrollTop = scrollTop;\n            bestItemIndex = itemIndex;\n            bestItemOffsetPtg = itemOffsetPtg;\n            bestStartIndex = startIndex;\n            bestEndIndex = endIndex;\n            missSimilarity = 0;\n          } else {\n            missSimilarity += 1;\n          }\n        } // If keeping 10 times not match similarity,\n        // check more scrollTop is meaningless.\n        // Here boundary is set to 10.\n\n\n        if (missSimilarity > 10) {\n          break;\n        }\n      } // 2. Re-scroll if has best scroll match\n\n\n      if (bestScrollTop !== null) {\n        this.lockScroll = true;\n        this.listRef.current.scrollTop = bestScrollTop;\n        this.setState({\n          status: 'MEASURE_START',\n          scrollTop: bestScrollTop,\n          itemIndex: bestItemIndex,\n          itemOffsetPtg: bestItemOffsetPtg,\n          startIndex: bestStartIndex,\n          endIndex: bestEndIndex\n        });\n        requestAnimationFrame(function () {\n          requestAnimationFrame(function () {\n            _this3.lockScroll = false;\n          });\n        });\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this$state5 = this.state,\n          isVirtual = _this$state5.isVirtual,\n          itemCount = _this$state5.itemCount;\n\n      var _this$props5 = this.props,\n          prefixCls = _this$props5.prefixCls,\n          style = _this$props5.style,\n          className = _this$props5.className,\n          _this$props5$componen = _this$props5.component,\n          Component = _this$props5$componen === void 0 ? 'div' : _this$props5$componen,\n          height = _this$props5.height,\n          itemHeight = _this$props5.itemHeight,\n          _this$props5$fullHeig = _this$props5.fullHeight,\n          fullHeight = _this$props5$fullHeig === void 0 ? true : _this$props5$fullHeig,\n          data = _this$props5.data,\n          children = _this$props5.children,\n          itemKey = _this$props5.itemKey,\n          onSkipRender = _this$props5.onSkipRender,\n          disabled = _this$props5.disabled,\n          virtual = _this$props5.virtual,\n          restProps = _objectWithoutProperties(_this$props5, [\"prefixCls\", \"style\", \"className\", \"component\", \"height\", \"itemHeight\", \"fullHeight\", \"data\", \"children\", \"itemKey\", \"onSkipRender\", \"disabled\", \"virtual\"]);\n\n      var mergedClassName = classNames(prefixCls, className); // Render pure list if not set height or height is enough for all items\n\n      if (!isVirtual) {\n        /**\n         * Virtual list switch is works on component updated.\n         * We should double check here if need cut the content.\n         */\n        var shouldVirtual = requireVirtual(height, itemHeight, data.length, virtual);\n        return React.createElement(Component, Object.assign({\n          style: height ? _objectSpread({}, style, _defineProperty({}, fullHeight ? 'height' : 'maxHeight', height), ScrollStyle) : style,\n          className: mergedClassName\n        }, restProps, {\n          onScroll: this.onRawScroll,\n          ref: this.listRef\n        }), React.createElement(Filler, {\n          prefixCls: prefixCls,\n          height: height\n        }, this.renderChildren(shouldVirtual ? data.slice(0, Math.ceil(height / itemHeight)) : data, 0, children)));\n      } // Use virtual list\n\n\n      var mergedStyle = _objectSpread({}, style, {\n        height: height\n      }, ScrollStyle);\n\n      var _this$state6 = this.state,\n          status = _this$state6.status,\n          startIndex = _this$state6.startIndex,\n          endIndex = _this$state6.endIndex,\n          startItemTop = _this$state6.startItemTop;\n      var contentHeight = itemCount * itemHeight * ITEM_SCALE_RATE;\n      return React.createElement(Component, Object.assign({\n        style: mergedStyle,\n        className: mergedClassName\n      }, restProps, {\n        onScroll: this.onScroll,\n        ref: this.listRef\n      }), React.createElement(Filler, {\n        prefixCls: prefixCls,\n        height: contentHeight,\n        offset: status === 'MEASURE_DONE' ? startItemTop : 0\n      }, this.renderChildren(data.slice(startIndex, endIndex + 1), startIndex, children)));\n    }\n  }], [{\n    key: \"getDerivedStateFromProps\",\n    value: function getDerivedStateFromProps(nextProps) {\n      if (!nextProps.disabled) {\n        return {\n          itemCount: nextProps.data.length\n        };\n      }\n\n      return null;\n    }\n  }]);\n\n  return List;\n}(React.Component);\n\nList.defaultProps = {\n  itemHeight: 15,\n  data: []\n};\nexport default List;"]},"metadata":{},"sourceType":"module"}